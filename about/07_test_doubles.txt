Test doubles заменяют объекты в течении тестов.
• Используют труднодоступные пути кода, такие как код обработки ошибок для надежной сторонней службы.
• Написания спецификации для слоя системы, прежде чем будут созданшы все его зависимости.
• Использования API, пока он в разработке, чтобы исправить проблемы с дизайном, прежде чем тратить время на реализацию.
• Продемонстрировать, как компонент работает по отношению к своим соседям в системе.
=============================================
в irb
require 'rspec/mocks/standalone'
=============================================
Типы Test Doubles:
В зависимости от режима использования двойников(usage mode):
Заглушка- Stub
  Возвращает готовые ответы, избегая каких-либо осмысленных вычислений или операций ввода-вывода.
Насмешка - Mock
  Ожидает конкретных сообщений; вызовет ошибку, если не получит их к концу примера
Нулевой объект - Null Object
  Доброкачественный тестовый двойник, который может заменить любой объект; возвращает себя в ответ на любое сообщение
Шпион - Spy
  Записывает полученные сообщения, чтобы вы могли проверить их позже

В зависимости от того как создаётся двойник(origin):
Чистый Двойник - Pure Double
  Двойник, поведение которого полностью зависит от тестовой среды; это то, о чем обычно думают люди, когда говорят о фиктивных объектах.
Частичный Двойник - Partial Double
  Существующий объект Ruby, который ведет себя как тестовое поведение; его интерфейс представляет собой смесь реальных и поддельных реализаций.
Подтвежденшный Двойник - Verifying Double
  Полностью поддельный, как чистый двойник, но ограничивает свой интерфейс на основе реального объекта, такого как частичный двойник; обеспечивает более безопасный двойной тест и проверку того, что он соответствует API, который он заменяет.
Заглушенная константа - Stubbed Constant
  Константа Ruby, например имя класса или модуля, которую вы создаете, удаляете или заменяете для одного теста.
===========================================
Режимы использования:
require 'rspec/mocks/standalone' подключаем irb
Генерация Тестовых Двойников
  в начале идет имя
  ledger = double => #<Double (anonymous)>
  ledger = double('Ledger') => #<Double "Ledger">
  ledger.record(an: :expense) возвратит ошибку
Пример заглушки (Stub)
  заглушками хорошо симулировать методы запросов
  http_response = double('HTTPResponse', status: 200, body: 'OK')
  http_response.status => 200
  http_response.body => 'OK'
  альтернативный способ
  http_response = double('HTTPResponse')
  allow(http_response).to receive_messages(status: 200, body: 'OK')
  или по одному
  allow(http_response).to receive(:status).and_return(200)
  allow(http_response).to receive(:body).and_return('OK')
Mock
  насмешки нужны, когда важены не значения, а получаемые еффекты
  - получить событие от системы
  - принять решение на основе этого события
  - выполнить действие, имеющее побочный эффект
  определение ожидания
  expect(ledger).to receive(:record)
  определение обратного ожидания
  expect(ledger).not_to receive(:reset)
  ручная верификация
  RSpec::Mocks.verify
  ledger.reset
Null Objects
  нулевые объекты нужны когда вашему тестовому двойнику нужно получить несколько сообщений, можно преобразовать любой тестовый двойник в нулевой:
  yoshi = double('Yoshi').as_null_object
  yoshi.eat(:apple)
  можно связать один вызов метода за другим для любого количества вызовов:
  yoshi.eat(:apple).then_shoot(:shell).then_stomp
Spies
  шпионы для востановления последовательности тестов утверждение\действие\ожидание
  class Game
    def self.play(character)
      character.jump
    end
  end
  mario = spy('Mario')
  Game.play(mario)
  expect(mario).to have_received(:jump)

================================================
Частичный Двойник - Partial Double
жестко захаркодить возвращаемое значение
  random = Random.new
  allow(random).to receive(:rand).and_return(0.1234)
  random.rand => 0.1234
выполнить очистку
  RSpec::Mocks.teardown
  random.rand => 0.9385928886462153
использовать частичного двойника, как шпиона
  allow(Dir).to receive(:mktmpdir).and_yield('/path/to/tmp')
  Dir.mktmpdir { |dir| puts "Dir is: #{dir}" } => Dir is: /path/to/tmp
  expect(Dir).to have_received(:mktmpdir)
-------------------------------------------
Верификация двойников
При создании двойника подобным образом, он
существует только в тестак, в реальном приложении его нет:
ledger = double('ExpenseTracker::Ledger')
allow(ledger).to receive(:record)
для того что бы была связь с реально существующими обьектами, применяют instance_double:
ledger = instance_double('ExpenseTracker::Ledger')
allow(ledger).to receive(:record)

Виды верификацированных двойников:
instance_double('SomeClass')
Ограничивает интерфейс двойника, используя методы экземпляра SomeClass.
class_double('SomeClass')
Ограничивает интерфейс двойника, используя методы класса SomeClass.
object_double(some_object)
Ограничивает интерфейс двойника, используя методы some_object, а не класса; удобно для динамических объектов, которые используют method_missing

Кроме того, у каждого из этих методов есть вариант _spy (например, instance_spy ) для удобства использования проверяющего двойника в качестве шпиона.
-------------------------------------------------
Stubbed Constants
Константы-заглушки позволяют:
  Определить новую константу
  Заменить существующую константу
  Замените весь модуль или класс (потому что это тоже константы)
  Избежать загрузки дорогого класса, используя вместо него легковесную подделку
Пример:
есть константа хаша пароля
class PasswordHash
  COST_FACTOR = 12
  # ...
end
можно опредиелить другое значение
stub_const('PasswordHash::COST_FACTOR', 1)

Можно скрыть константу для конкретного примера:
hide_const('ActiveRecord')
